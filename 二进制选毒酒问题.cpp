/*
今天在算法设计与分析课程上，讲到了一道很有意思的题目，听说是百度的面试题，一起来看看吧！
题目概述：有1000桶酒，其中一桶有毒，而一旦吃了，毒性会在一周后发作。现在我们用小老鼠做实验，要在一周后找出那桶酒，问最少需要多少桶酒？
题目分析：1000桶酒中仅有1桶有毒！注意这个1，如何运用最少的老鼠数来测出这桶毒酒呢？
*/

/*
  上课看到这道题目，一脸懵逼，不如找1000只老鼠一只尝一口hhh，显然不合理，但这个最最普通的思路已经提出了最基本的思想：1000桶酒必须对应1000种不同的状态，
  作为一名计科学生，大家一定立刻想到了二进制的表示形式，2^(10)=1024,10位二进制代码恰好对应1024种状态，那是不是可以分别用1位二进制代表一只老鼠
  0000000001（1号），0000000010（2号）......那最后所有死掉的老鼠，相加的和对应一个十进制编号，这瓶酒就是那瓶毒酒了吧，懂了么？如最后死掉的老鼠仅有：1号，2号，3号
  那么那瓶毒酒一定是0000000111；那是不是想到了测试这1000瓶酒的方法：按自己的编号让每只老鼠尝试（总之二进制的最迷人之处大概就在于它仅有0和1两种状态了吧）
*/

/*
author:@twilight
Time:20190916
说明：是个讨论题，来输入最后死亡老鼠的编号，来输出最后的毒酒编号吧。
为了不那么简单，要求输入十进制，指出老鼠编号，指出毒酒对应十进制下的编号
*/

#include<iostream>
using namespace std;

void DtoB(int a){
	int b=0,i=0,j=9;
	int out=0;
	int A[10];//存放二进制结果
	while (i<10) {
		b = a % 2;
		a = a / 2;
		A[j] = b;
		i++;
		j--;
	}
	for (i = 0; i < 10; i++)
		cout << A[i];
};//写了个算法实现十进制到二进制的转化

int main()
{
	int i, j;
	int A[10];
	int deathnum[10];//死亡老鼠的编号
	int poision=0;
	cout << "请输入最后的老鼠死亡个数" << endl;
	int n;//死亡老鼠数
	cin >> n;
	cout << "请输入死亡老鼠的十进制编号" << endl;
	for (i = 0; i < n; i++)
	{
		cin >> deathnum[i];

	}cout << "死亡老鼠的二进制序号分别是：";
	for (i = 0; i < n; i++)
	{ 
		DtoB(deathnum[i]);
	cout << " ";
	}
	for (i = 0; i < n; i++)
		poision += deathnum[i];
	cout << "毒酒的序号是：" << poision;
	return 0;
}