/*
算术运算应用中的一道例题：我们把相隔一个数据的两个数称作“一对数”，求一个由整形数据构成的圆圈中一对数的最大值与最小值
我把这道题单拿出来做分析是因为它的存储方式值的一提
首先从题目中获知，数据之间存在前后位置关系，而用数组元素下标访问具有这种特性的数据无疑是最方便的，
可这道题的特殊之处在于，所有数据需要构成一个循环圆圈
我是没有思路的，除非像Joseph问题的数组实现方式一样，时刻监测数组元素下标越界的情况，发生越界对其立刻进行修改
不过这道题在思路中提出的一个很好的方法是通过求余运算规定数组的第一个数和最后一个数（比较一对数要求的是间隔有一个数字的两个数）
*/
#include<iostream>
using namespace std;
int main()
{
	int max = 1, min=0x3f3f3f;//为数据寄存器赋初值，便于之后的比较操作；
	int a[100];//圆圈存储器
	int num,k;//圆圈中包含数据的个数
	int cal1 = 1, cal2 = 1;//用于记录两个乘数
	int cal3 = 1, cal4 = 1;//用于记录两个乘数
	cin >> num;
	for (int i = 0; i < num; i++)
	{
		cin >> k;
		a[i] = k;
	}
	for (int i = 0; i < num; i++) {//把数组里的所有数字全检查一遍
		int p = (num + i - 1) % num;//求数i-1对应的下标，因为是循环数组，采用求余运算
		int q = (i + 1) % num;//i=num-1时能保证该式的值等于0,达到了循环的目的
		int res = a[q] * a[p];
		if (res > max) {
			max = res;
			cal1 = a[p];
			cal2 = a[q];
		}
		if (res < min) {
			min = res;
			cal3 = a[p]; 
			cal4 =a[q];
		}
	}
	cout << "max=" << max << ",=" << cal1 << "*"<<cal2 << endl;
	cout << "min=" << min << ",=" << cal3 << "*" << cal4 << endl;
	return 0;
}
